# -*- coding: utf-8 -*-
# ====================================================
#
#   Copyright (c) 2023 Nuoyan
#   nuoyanlib is licensed under Mulan PSL v2.
#   You can use this software according to the terms and conditions of the Mulan PSL v2.
#   You may obtain a copy of Mulan PSL v2 at:
#            http://license.coscl.org.cn/MulanPSL2
#   THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
#   See the Mulan PSL v2 for more details.
#
#   Author        : 诺言Nuoyan
#   Email         : 1279735247@qq.com
#   Gitee         : https://gitee.com/charming-lee
#   Last Modified : 2024-04-30
#
# ====================================================


from typing import List, Dict, Union, Optional, Tuple, Set, Callable, Any
from mod.client.ui.controls.progressBarUIControl import ProgressBarUIControl
from mod.client.ui.controls.buttonUIControl import ButtonUIControl
from mod.client.system.clientSystem import ClientSystem
from mod.client.ui.screenNode import ScreenNode
from item_fly_anim import ItemFlyAnim
from item_tips_box import ItemTipsBox
from screen_node import ui_listener, NuoyanScreenNode


_IMAGE_PATH_ITEM_CELL_SELECTED: str
_IMAGE_PATH_ITEM_CELL_DEFAULT: str
_UI_NAME_COUNT: str
_UI_NAME_ITEM_RENDERER: str
_UI_NAME_DURABILITY: str
_UI_NAME_DEFAULT: str
_UI_NAME_HEAP: str
_UI_NAME_ITEM_BG: str
_SHORTCUT: str
_INV27: str
_INV36: str
_RESERVED_KEYS = Tuple[str, str, str]


def _deepcopy(obj: dict) -> dict: ...
def _listen_item_changes(func: Callable) -> Callable: ...
def _analyze_changes(
    old: Dict[str, List[Optional[dict]]],
    new: Dict[str, List[Optional[dict]]],
) -> Dict[Tuple[str, int], Dict[str, Optional[dict]]]: ...
def _update_changes(
    old_changes: Dict[Tuple[str, int], Dict[str, Optional[dict]]],
    new_changes: Dict[Tuple[str, int], Dict[str, Optional[dict]]],
) -> None: ...


class ItemGridManager(ItemFlyAnim, ItemTipsBox, NuoyanScreenNode):
    _cs: ClientSystem
    __screen_node: ScreenNode
    _grid_items_data: Dict[str, List[Optional[dict]]]
    _item_heap_data: Dict[str, Union[dict, int, bool, ProgressBarUIControl]]
    _selected_item: Dict[str, Union[dict, str]]
    _grid_paths: Dict[str, Tuple[str, bool]]
    _grid_keys: List[str]
    _cell_paths: Dict[Tuple[str, int], str]
    _cell_poses: Dict[str, Tuple[str, int]]
    _cell_ui_ctrls: Dict[str, List[ButtonUIControl]]
    __changes: Dict[Tuple[str, int], Dict[str, dict]]
    _locked_cells: Set[Tuple[str, int]]
    _locked_grids: Set[str]
    __move_in_grid_list: List[str]
    _inited_keys: List[str]
    __tick: int
    __org_item: dict
    __namespace: str
    def __init__(self: ..., namespace: str, name: str, param: Optional[dict]) -> None: ...
    def Destroy(self: ...) -> None: ...
    @ui_listener("GetEntityByCoordReleaseClientEvent")
    def _GetEntityByCoordReleaseClientEvent1(self: ..., args: dict) -> None: ...
    @ui_listener("InventoryItemChangedClientEvent")
    def _InventoryItemChangedClientEvent(self: ..., args: dict) -> None: ...
    def OnMoveItemsBefore(self: ..., args: dict) -> None: ...
    def OnMoveItemsAfter(self: ..., args: dict) -> None: ...
    def OnReceiveItemsDataFromServerBefore(self: ..., args: dict) -> None: ...
    def OnItemGridChanged(self: ..., args: dict) -> None: ...
    def OnItemGridSelectedItem(self: ..., args: dict) -> None: ...
    def OnItemCellTouchUp(self: ..., args: dict) -> None: ...
    def _on_item_cell_touch_up(self: ..., args: dict) -> None: ...
    def OnItemCellTouchMoveIn(self: ..., args: dict) -> None: ...
    def _on_item_cell_touch_move_in(self: ..., args: dict) -> None: ...
    def OnItemCellDoubleClick(self: ..., args: dict) -> None: ...
    def _on_item_cell_double_click(self: ..., args: dict) -> None: ...
    def OnItemCellLongClick(self: ..., args: dict) -> None: ...
    def _on_item_cell_long_click(self: ..., args: dict) -> None: ...
    def OnItemCellTouchDown(self: ..., args: dict) -> None: ...
    def _on_item_cell_touch_down(self: ..., args: dict) -> None: ...
    def OnItemCellTouchMove(self: ..., args: dict) -> None: ...
    def OnItemCellTouchMoveOut(self: ..., args: dict) -> None: ...
    def OnItemCellTouchCancel(self: ..., args: dict) -> None: ...
    def GetAllItemCellUIControls(self: ..., key: str) -> List[ButtonUIControl]: ...
    def GetItemCellUIControl(self: ..., cell: Union[str, Tuple[str, int]]) -> Optional[ButtonUIControl]: ...
    def SetItemCellDurabilityBar(
        self: ...,
        cell: Union[str, Tuple[str, int]],
        item_dict: dict = None,
        auto: bool = False,
    ) -> bool: ...
    def SetItemCellRenderer(
        self: ...,
        cell: Union[str, Tuple[str, int]],
        item_dict: dict = None,
        auto: bool = False,
    ) -> bool: ...
    def SetItemCellCountLabel(
        self: ...,
        cell: Union[str, Tuple[str, int]],
        item_dict: dict = None,
        auto: bool = False,
    ) -> bool: ...
    def UpdateAndSyncItemGrids(self: ..., keys: Optional[str, Tuple[str, ...]] = None) -> bool: ...
    def ClearItemGridState(self: ...) -> bool: ...
    def _set_item_fly_anim(
        self: ...,
        item_dict: dict,
        from_cell: Union[str, Tuple[str, int]],
        to_cell: Union[str, Tuple[str, int]],
    ) -> None: ...
    def StartItemHeapProgressBar(self: ...) -> bool: ...
    def PauseItemHeapProgressBar(self: ...) -> bool: ...
    def LockItemGrid(self: ..., key: str, lock: bool) -> bool: ...
    def IsItemGridLocked(self: ..., key: str) -> bool: ...
    def LockItemCell(self: ..., cell: Union[str, Tuple[str, int]], lock: bool) -> bool: ...
    def IsItemCellLocked(self: ..., cell: Union[str, Tuple[str, int]]) -> bool: ...
    def _is_cell_exist(self: ..., *cell: Union[str, Tuple[str, int]]) -> bool: ...
    @_listen_item_changes
    def _set_cell_ui_item(self: ..., cell: Union[str, Tuple[str, int]], item_dict: Optional[dict]) -> None: ...
    def SetItemGridItems(self: ..., item_dict_list: List[dict], key: str, sync: bool = True) -> bool: ...
    def GetItemGridItems(self: ..., key: str) -> List[Optional[dict]]: ...
    def SetItemCellItem(self: ..., cell: Union[str, Tuple[str, int]], item_dict: dict, sync: bool = True) -> bool: ...
    def GetItemCellItem(self: ..., cell: Union[str, Tuple[str, int]]) -> Optional[dict]: ...
    def MoveItems(
        self: ...,
        from_cell: Union[str, Tuple[str, int]],
        to_cell: Union[str, Tuple[str, int]],
        move_count: int = -1,
        sync: bool = True,
        fly_anim: bool = True,
        force: bool = False,
    ) -> bool: ...
    def _exchange_items(
        self: ...,
        from_cell: Union[str, Tuple[str, int]],
        to_cell: Union[str, Tuple[str, int]],
    ) -> None: ...
    def _move_items_to_empty(
        self: ...,
        from_cell: Union[str, Tuple[str, int]],
        to_cell: Union[str, Tuple[str, int]],
        count: int,
    ) -> None: ...
    def _move_items_to_same(
        self: ...,
        from_cell: Union[str, Tuple[str, int]],
        to_cell: Union[str, Tuple[str, int]],
        count: int,
    ) -> None: ...
    def MergeItems(
        self: ...,
        to_cell: Union[str, Tuple[str, int]],
        sync: bool = True,
        fly_anim: bool = True,
    ) -> bool: ...
    @_listen_item_changes
    def SeparateItemsEvenly(
        self: ...,
        from_cell: Union[str, Tuple[str, int]],
        from_org_item: dict,
        to_cell_list: List[Union[str, Tuple[str, int]]],
        sync: bool = True,
    ) -> bool: ...
    @_listen_item_changes
    def SetItemCellCount(
        self: ...,
        cell: Union[str, Tuple[str, int]],
        count: int,
        absolute: int = 0,
        sync: bool = True,
    ) -> int: ...
    def GetItemCellCount(self: ..., cell: Union[str, Tuple[str, int]]) -> int: ...
    def ReturnItemsToInv(self: ..., keys: Optional[Union[str, Tuple[str, ...]]] = None) -> bool: ...
    @_listen_item_changes
    def PutItemToGrids(
        self: ...,
        put_item: Union[dict, Union[str, Tuple[str, int]]],
        keys: Optional[Union[str, Tuple[str, ...]]] = None,
        sync: bool = True,
        fly_anim: bool = True,
    ) -> List[Tuple[str, int]]: ...
    def _put_item(self: ..., put_item: dict, key: str) -> List[Tuple[str, int]]: ...
    def ThrowItem(
        self: ...,
        what: Union[dict, Union[str, Tuple[str, int]]],
        count: int = -1,
        sync: bool = True,
    ) -> bool: ...
    def SyncAllItemsFromServer(self: ..., keys: Optional[Union[str, Tuple[str, ...]]] = None) -> bool: ...
    @ui_listener(namespace="NuoyanLib", system_name="_TransitServerSystem")
    def _SyncItems(self: ..., args: dict) -> None: ...
    def SetSelectedItem(self: ..., cell: Union[str, Tuple[str, int]], selected: bool = True) -> bool: ...
    def GetSelectedItem(self: ...) -> Dict[str, Union[dict, str]]: ...
    def SetItemHeapData(
        self: ...,
        cell: Union[str, Tuple[str, int]],
        count: int,
    ) -> Optional[Dict[str, Union[dict, int, bool, ProgressBarUIControl]]]: ...
    def GetItemHeapData(self: ...) -> Dict[str, Union[dict, int, bool, ProgressBarUIControl]]: ...
    def RegisterItemGrid(self: ..., key: str, path: str, isSingle: bool = False) -> bool: ...
    def InitItemGrids(
        self: ...,
        keys: Union[str, List[str], None] = None,
        callback: Optional[Callable] = None,
        *args: Any,
        **kwargs: Any,
    ) -> bool: ...
    def _init_item_grids(
        self: ...,
        keys: List[str],
        callback: Optional[Callable],
        args: Tuple[Any, ...],
        kwargs: Dict[str, Any],
    ) -> None: ...
    def AllItemGridsInited(self: ..., keys: Union[str, List[str], None] = None) -> bool: ...
    def GetItemGridKey(self: ..., cell: Union[str, Tuple[str, int]]) -> Optional[str]: ...
    def GetItemCellPath(self: ..., cell: Union[str, Tuple[str, int]]) -> Optional[str]: ...
    def GetItemCellPos(self: ..., cell: Union[str, Tuple[str, int]]) -> Optional[Tuple[str, int]]: ...
